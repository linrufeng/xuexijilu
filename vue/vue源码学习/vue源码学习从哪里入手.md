## Vue 源码学习
在项目里面找到vue的文件夹vue/dist
通过readme 这个文件我们可以了解vue各种版本的作用
#### Vue 按照不同的打包方式
按照不同的模块需求有多重编译方式,也对应多个编译文件.从基础功能上划分，就分为运行时版本和完整版本。由此可见其核心在运行时模块。
接下来就是去找运行时模块的入口了。为了适配当前主流的模块化方案，Vue 的打包方案又分为 
**UMD，CommomJS，ES Module(基于构建工具使用）、ES Module(基于浏览器)**
![Image text](https://upload-images.jianshu.io/upload_images/4580053-c745ec444df69f08.png?imageMogr2/auto-orient/)

在什么都不了解情况下我们不妨就读读vue.js 

双击后面的vue 就进去了。
#为什么读vue源码？
个人觉得
最浅显的道理，观摩源码可以一定程度上改变我们的编码习惯。
学习大项目的开发路数
其二，有助于了解其中的原理，让我们在开发过程中知道哪里写错了
其三。。。。
我们看到vue的项目结构 我们发现vue是用了typescript的
在types这个文件夹下 里面定义了vue各种对象的类型 index.d.ts 是总的出口
# 怎么读源码
1、首先要借助调试工具。
2、读源码也是有目的的，大部分的我们也没有那么多时间一行行的吧啦，所以要带着目的读。

vue最有魅力的地方就是双向数据绑定和虚拟vnode 所以读 我们这次先了解这块

##vue 框架运行的三个重要阶段

配置项校验合并阶段
参见Vue源码分析(3)--选项合并过程mergeOptions

初始化响应式系统
参见Vue源码分析(4)--实例的初始化过程

组件挂载、依赖收集、页面更新(Virtual DOM Diff)
参见Vue源码分析(5)--观察者收集、组件渲染挂载过程

vue 框架的三大核心内容

响应式系统
data中的对象obj会被观测(observe)，结果就是obj的每个可枚举属性都被配置了一个dep属性，专门用来收集各种watcher实例(通过Object.defineProperty重写了属性的存取器函数办到的)。当组件开始挂载时（vm.$mount(vm.options.el)），组件的render函数被调用，从而触发了属性的get函数，该属性对应的dep就会收集当前活跃的watcher实例(也即render watcher)，挂载完毕后页面的初次渲染就完成了。当data中的数据发生变化时会触发对应属性的set函数，set函数会调用该属性对应的dep中的wathcer实例的run方法，该方法最终经过Diff算法算出页面最小变动部分，从而实现页面更新。
模板编译系统
通过正则手段，将vue语法格式的html字符串解析成AST，最终通过字符串拼接的方式产生render和renderStatic函数
批量更新 & Diff 算法
页面初次渲染后，如果data中的数据发生变化，比如a,b两个属性发生变化，并不是a属性变化时更新一下页面，b属性变化时再更新一下页面，而是a,b两个属性都变化以后只更新一次页面(前提是ab的变化不是异步的)，这就是批量更新的意思。实现的原理是内部实现了nextTick函数，触发属性的set函数时，会将该属性收集的watcher放入队列中，等此次事件循环结束后统一在下次循环时依次执行（本质上执行watcher.run方法）；
Diff算法是按层级比较的，因此时间复杂度为o(n)，效率上是很高效的(暂未深入研究)

## vue 是如何实例化的



